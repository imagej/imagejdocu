&lt;code&gt;
//Example macro that does a diffusion analysis on a results table of tracking 
//data. The required format is as generated by the Manual Tracking plugin 
//http://rsbweb.nih.gov/ij/plugins/track/track.html
//assuming Results table column headings: Track &gt; Slice &gt; X &gt; Y
//It requires many tracks and many time points!
//The analysis uses the time ensemble average method described in Charsooghi, MA et al 2011
//http://www.sciencedirect.com/science/article/pii/S0010465510003620

//Get number of tracks (nTracks)
nTracks = 0;
for (a=0; a&lt;nResults(); a++) {
    if (getResult(&quot;Track&quot;,a)&gt;nTracks)
    {
     nTracks = getResult(&quot;Track&quot;,a);
    	}
    	else{};
}

//Find the track length for each track - write track length to results table
//some variables
Track=1;
L_Track=0;

//work though tracks and determine length
for (i=0; i&lt;nResults(); i++){
	if (getResult(&quot;Track&quot;, i)==Track) {L_Track++;} else {

//Do this if its the first track
	if(Track==1){		for (j=(i-L_Track); j&lt;i; j++){
				setResult(&quot;T_Length&quot;, j, L_Track);			
		}
				L_Track=0;
				Track++;
				
//Do this if its in the middle
	L_Track=1;	
	} else {for (j=(i-L_Track); j&lt;i; j++){
				setResult(&quot;T_Length&quot;, j, L_Track);
		}
				L_Track=1;
				Track++;
			}
		}
	}
//Do this to get the last track
	L_Track=0;
	for (j=0; j&lt;nResults; j++) {
		if (getResult(&quot;Track&quot;, j)==nTracks) {L_Track++;}
	}

	for (k=0; k&lt;nResults; k++) {
		if (getResult(&quot;Track&quot;, k)==nTracks) {setResult(&quot;T_Length&quot;, k, L_Track);
	}
}
updateResults();

//get last slice
maxslice = 0;
for (b=0; b&lt;nResults(); b++) {
    if (getResult(&quot;Slice&quot;,b)&gt;maxslice)
    {
     maxslice = getResult(&quot;Slice&quot;,b);
    	}
    	else{};
}

//get first slice
minslice = maxslice;
for (c=0; c&lt;nResults(); c++) {
    if (getResult(&quot;Slice&quot;,c)&lt;minslice)
    {
     minslice = getResult(&quot;Slice&quot;,c);
    	}
    	else{};
}

//The window sizes for analysis range from 1-step to - maxslice-1
//Calculate squared dispalcement from tracking data for all possible window sizes 

MSD = newArray();
time = newArray();
divide=0;
r_total=0;
dis2 = 0;

for (u=1; u&lt;(maxslice); u++) {

for (i=0; i&lt;nResults(); i++){
	if (getResult(&quot;Slice&quot;, i)&lt;=u) {}
	
	else{ if (getResult(&quot;Track&quot;, i)&gt;getResult(&quot;Track&quot;, i-u)) {}
	
	else { if (getResult(&quot;T_Length&quot;, i)&gt;=u &amp;&amp; getResult(&quot;Track&quot;, i-u)==getResult(&quot;Track&quot;, i)) {
	B9 = getResult(&quot;X&quot;, i);
	B8 = getResult(&quot;X&quot;, i-u);
	C9 = getResult(&quot;Y&quot;, i);
	C8 = getResult(&quot;Y&quot;, i-u);
	disx2 = (B9-B8)*(B9-B8);
	disy2 = (C9-C8)*(C9-C8);
	dis2 = (disx2 + disy2);
	r_total = r_total+dis2;	
	divide++;
			}	
		}
	}
}
time = Array.concat(time, u);	
MSD = Array.concat(MSD, (r_total)/divide);
r_total=0;
divide=0;
}

Fit.doFit(&quot;Straight Line&quot;, time, MSD);
intercept = d2s(Fit.p(0),6);
slope = d2s(Fit.p(1),6);
r2 = d2s(Fit.rSquared,3);
print(&quot;slope = &quot;+slope);
print(&quot;intercept = &quot;+intercept);
print(&quot;R^2 = &quot;+r2);
Fit.plot();

//Richard Mort 26/01/2013

&lt;/code&gt;
